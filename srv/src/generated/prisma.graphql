# THIS FILE HAS BEEN AUTO-GENERATED BY "PRISMA DEPLOY"
# DO NOT EDIT THIS FILE DIRECTLY

#
# Model Types
#

type Game implements Node {
  id: ID!
  title: String!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  rules(where: RuleWhereInput, orderBy: RuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rule!]
  ruleCount: Int
  rulesetCount: Int
}

type Rule implements Node {
  id: ID!
  game(where: GameWhereInput): Game!
  ruleText: String!
  categories: [String!]
  author(where: UserWhereInput): User!
  rulesets(where: RulesetWhereInput, orderBy: RulesetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ruleset!]
}

type Ruleset implements Node {
  id: ID!
  game(where: GameWhereInput): Game!
  name: String!
  rules(where: RuleWhereInput, orderBy: RuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rule!]
  author(where: UserWhereInput): User!
}

type User implements Node {
  id: ID!
  email: String!
  name: String
  avatar: String
  auth0id: String!
  identity: String
  games(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game!]
  rules(where: RuleWhereInput, orderBy: RuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rule!]
  rulesets(where: RulesetWhereInput, orderBy: RulesetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ruleset!]
}


#
# Other Types
#

type AggregateGame {
  count: Int!
}

type AggregateRule {
  count: Int!
}

type AggregateRuleset {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type GameConnection {
  pageInfo: PageInfo!
  edges: [GameEdge]!
  aggregate: AggregateGame!
}

input GameCreateInput {
  title: String!
  ruleCount: Int
  rulesetCount: Int
  users: UserCreateManyWithoutGamesInput
  rules: RuleCreateManyWithoutGameInput
}

input GameCreateManyWithoutUsersInput {
  create: [GameCreateWithoutUsersInput!]
  connect: [GameWhereUniqueInput!]
}

input GameCreateOneInput {
  create: GameCreateInput
  connect: GameWhereUniqueInput
}

input GameCreateOneWithoutRulesInput {
  create: GameCreateWithoutRulesInput
  connect: GameWhereUniqueInput
}

input GameCreateWithoutRulesInput {
  title: String!
  ruleCount: Int
  rulesetCount: Int
  users: UserCreateManyWithoutGamesInput
}

input GameCreateWithoutUsersInput {
  title: String!
  ruleCount: Int
  rulesetCount: Int
  rules: RuleCreateManyWithoutGameInput
}

type GameEdge {
  node: Game!
  cursor: String!
}

enum GameOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  ruleCount_ASC
  ruleCount_DESC
  rulesetCount_ASC
  rulesetCount_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type GamePreviousValues {
  id: ID!
  title: String!
  ruleCount: Int
  rulesetCount: Int
}

type GameSubscriptionPayload {
  mutation: MutationType!
  node: Game
  updatedFields: [String!]
  previousValues: GamePreviousValues
}

input GameSubscriptionWhereInput {
  AND: [GameSubscriptionWhereInput!]
  OR: [GameSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GameWhereInput
}

input GameUpdateDataInput {
  title: String
  ruleCount: Int
  rulesetCount: Int
  users: UserUpdateManyWithoutGamesInput
  rules: RuleUpdateManyWithoutGameInput
}

input GameUpdateInput {
  title: String
  ruleCount: Int
  rulesetCount: Int
  users: UserUpdateManyWithoutGamesInput
  rules: RuleUpdateManyWithoutGameInput
}

input GameUpdateManyWithoutUsersInput {
  create: [GameCreateWithoutUsersInput!]
  connect: [GameWhereUniqueInput!]
  disconnect: [GameWhereUniqueInput!]
  delete: [GameWhereUniqueInput!]
  update: [GameUpdateWithoutUsersInput!]
  upsert: [GameUpsertWithoutUsersInput!]
}

input GameUpdateNestedInput {
  where: GameWhereUniqueInput!
  data: GameUpdateDataInput!
}

input GameUpdateOneInput {
  create: GameCreateInput
  connect: GameWhereUniqueInput
  disconnect: GameWhereUniqueInput
  delete: GameWhereUniqueInput
  update: GameUpdateNestedInput
  upsert: GameUpsertNestedInput
}

input GameUpdateOneWithoutRulesInput {
  create: GameCreateWithoutRulesInput
  connect: GameWhereUniqueInput
  disconnect: GameWhereUniqueInput
  delete: GameWhereUniqueInput
  update: GameUpdateWithoutRulesInput
  upsert: GameUpsertWithoutRulesInput
}

input GameUpdateWithoutRulesDataInput {
  title: String
  ruleCount: Int
  rulesetCount: Int
  users: UserUpdateManyWithoutGamesInput
}

input GameUpdateWithoutRulesInput {
  where: GameWhereUniqueInput!
  data: GameUpdateWithoutRulesDataInput!
}

input GameUpdateWithoutUsersDataInput {
  title: String
  ruleCount: Int
  rulesetCount: Int
  rules: RuleUpdateManyWithoutGameInput
}

input GameUpdateWithoutUsersInput {
  where: GameWhereUniqueInput!
  data: GameUpdateWithoutUsersDataInput!
}

input GameUpsertNestedInput {
  where: GameWhereUniqueInput!
  update: GameUpdateDataInput!
  create: GameCreateInput!
}

input GameUpsertWithoutRulesInput {
  where: GameWhereUniqueInput!
  update: GameUpdateWithoutRulesDataInput!
  create: GameCreateWithoutRulesInput!
}

input GameUpsertWithoutUsersInput {
  where: GameWhereUniqueInput!
  update: GameUpdateWithoutUsersDataInput!
  create: GameCreateWithoutUsersInput!
}

input GameWhereInput {
  AND: [GameWhereInput!]
  OR: [GameWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  ruleCount: Int
  ruleCount_not: Int
  ruleCount_in: [Int!]
  ruleCount_not_in: [Int!]
  ruleCount_lt: Int
  ruleCount_lte: Int
  ruleCount_gt: Int
  ruleCount_gte: Int
  rulesetCount: Int
  rulesetCount_not: Int
  rulesetCount_in: [Int!]
  rulesetCount_not_in: [Int!]
  rulesetCount_lt: Int
  rulesetCount_lte: Int
  rulesetCount_gt: Int
  rulesetCount_gte: Int
  users_every: UserWhereInput
  users_some: UserWhereInput
  users_none: UserWhereInput
  rules_every: RuleWhereInput
  rules_some: RuleWhereInput
  rules_none: RuleWhereInput
}

input GameWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createGame(data: GameCreateInput!): Game!
  createRule(data: RuleCreateInput!): Rule!
  createRuleset(data: RulesetCreateInput!): Ruleset!
  createUser(data: UserCreateInput!): User!
  updateGame(data: GameUpdateInput!, where: GameWhereUniqueInput!): Game
  updateRule(data: RuleUpdateInput!, where: RuleWhereUniqueInput!): Rule
  updateRuleset(data: RulesetUpdateInput!, where: RulesetWhereUniqueInput!): Ruleset
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  deleteGame(where: GameWhereUniqueInput!): Game
  deleteRule(where: RuleWhereUniqueInput!): Rule
  deleteRuleset(where: RulesetWhereUniqueInput!): Ruleset
  deleteUser(where: UserWhereUniqueInput!): User
  upsertGame(where: GameWhereUniqueInput!, create: GameCreateInput!, update: GameUpdateInput!): Game!
  upsertRule(where: RuleWhereUniqueInput!, create: RuleCreateInput!, update: RuleUpdateInput!): Rule!
  upsertRuleset(where: RulesetWhereUniqueInput!, create: RulesetCreateInput!, update: RulesetUpdateInput!): Ruleset!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  updateManyGames(data: GameUpdateInput!, where: GameWhereInput!): BatchPayload!
  updateManyRules(data: RuleUpdateInput!, where: RuleWhereInput!): BatchPayload!
  updateManyRulesets(data: RulesetUpdateInput!, where: RulesetWhereInput!): BatchPayload!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload!
  deleteManyGames(where: GameWhereInput!): BatchPayload!
  deleteManyRules(where: RuleWhereInput!): BatchPayload!
  deleteManyRulesets(where: RulesetWhereInput!): BatchPayload!
  deleteManyUsers(where: UserWhereInput!): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  games(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game]!
  rules(where: RuleWhereInput, orderBy: RuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rule]!
  rulesets(where: RulesetWhereInput, orderBy: RulesetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ruleset]!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  game(where: GameWhereUniqueInput!): Game
  rule(where: RuleWhereUniqueInput!): Rule
  ruleset(where: RulesetWhereUniqueInput!): Ruleset
  user(where: UserWhereUniqueInput!): User
  gamesConnection(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GameConnection!
  rulesConnection(where: RuleWhereInput, orderBy: RuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RuleConnection!
  rulesetsConnection(where: RulesetWhereInput, orderBy: RulesetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RulesetConnection!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type RuleConnection {
  pageInfo: PageInfo!
  edges: [RuleEdge]!
  aggregate: AggregateRule!
}

input RuleCreatecategoriesInput {
  set: [String!]
}

input RuleCreateInput {
  ruleText: String!
  categories: RuleCreatecategoriesInput
  game: GameCreateOneWithoutRulesInput!
  author: UserCreateOneWithoutRulesInput!
  rulesets: RulesetCreateManyWithoutRulesInput
}

input RuleCreateManyWithoutAuthorInput {
  create: [RuleCreateWithoutAuthorInput!]
  connect: [RuleWhereUniqueInput!]
}

input RuleCreateManyWithoutGameInput {
  create: [RuleCreateWithoutGameInput!]
  connect: [RuleWhereUniqueInput!]
}

input RuleCreateManyWithoutRulesetsInput {
  create: [RuleCreateWithoutRulesetsInput!]
  connect: [RuleWhereUniqueInput!]
}

input RuleCreateWithoutAuthorInput {
  ruleText: String!
  categories: RuleCreatecategoriesInput
  game: GameCreateOneWithoutRulesInput!
  rulesets: RulesetCreateManyWithoutRulesInput
}

input RuleCreateWithoutGameInput {
  ruleText: String!
  categories: RuleCreatecategoriesInput
  author: UserCreateOneWithoutRulesInput!
  rulesets: RulesetCreateManyWithoutRulesInput
}

input RuleCreateWithoutRulesetsInput {
  ruleText: String!
  categories: RuleCreatecategoriesInput
  game: GameCreateOneWithoutRulesInput!
  author: UserCreateOneWithoutRulesInput!
}

type RuleEdge {
  node: Rule!
  cursor: String!
}

enum RuleOrderByInput {
  id_ASC
  id_DESC
  ruleText_ASC
  ruleText_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type RulePreviousValues {
  id: ID!
  ruleText: String!
  categories: [String!]
}

type RulesetConnection {
  pageInfo: PageInfo!
  edges: [RulesetEdge]!
  aggregate: AggregateRuleset!
}

input RulesetCreateInput {
  name: String!
  game: GameCreateOneInput!
  rules: RuleCreateManyWithoutRulesetsInput
  author: UserCreateOneWithoutRulesetsInput!
}

input RulesetCreateManyWithoutAuthorInput {
  create: [RulesetCreateWithoutAuthorInput!]
  connect: [RulesetWhereUniqueInput!]
}

input RulesetCreateManyWithoutRulesInput {
  create: [RulesetCreateWithoutRulesInput!]
  connect: [RulesetWhereUniqueInput!]
}

input RulesetCreateWithoutAuthorInput {
  name: String!
  game: GameCreateOneInput!
  rules: RuleCreateManyWithoutRulesetsInput
}

input RulesetCreateWithoutRulesInput {
  name: String!
  game: GameCreateOneInput!
  author: UserCreateOneWithoutRulesetsInput!
}

type RulesetEdge {
  node: Ruleset!
  cursor: String!
}

enum RulesetOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type RulesetPreviousValues {
  id: ID!
  name: String!
}

type RulesetSubscriptionPayload {
  mutation: MutationType!
  node: Ruleset
  updatedFields: [String!]
  previousValues: RulesetPreviousValues
}

input RulesetSubscriptionWhereInput {
  AND: [RulesetSubscriptionWhereInput!]
  OR: [RulesetSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RulesetWhereInput
}

input RulesetUpdateInput {
  name: String
  game: GameUpdateOneInput
  rules: RuleUpdateManyWithoutRulesetsInput
  author: UserUpdateOneWithoutRulesetsInput
}

input RulesetUpdateManyWithoutAuthorInput {
  create: [RulesetCreateWithoutAuthorInput!]
  connect: [RulesetWhereUniqueInput!]
  disconnect: [RulesetWhereUniqueInput!]
  delete: [RulesetWhereUniqueInput!]
  update: [RulesetUpdateWithoutAuthorInput!]
  upsert: [RulesetUpsertWithoutAuthorInput!]
}

input RulesetUpdateManyWithoutRulesInput {
  create: [RulesetCreateWithoutRulesInput!]
  connect: [RulesetWhereUniqueInput!]
  disconnect: [RulesetWhereUniqueInput!]
  delete: [RulesetWhereUniqueInput!]
  update: [RulesetUpdateWithoutRulesInput!]
  upsert: [RulesetUpsertWithoutRulesInput!]
}

input RulesetUpdateWithoutAuthorDataInput {
  name: String
  game: GameUpdateOneInput
  rules: RuleUpdateManyWithoutRulesetsInput
}

input RulesetUpdateWithoutAuthorInput {
  where: RulesetWhereUniqueInput!
  data: RulesetUpdateWithoutAuthorDataInput!
}

input RulesetUpdateWithoutRulesDataInput {
  name: String
  game: GameUpdateOneInput
  author: UserUpdateOneWithoutRulesetsInput
}

input RulesetUpdateWithoutRulesInput {
  where: RulesetWhereUniqueInput!
  data: RulesetUpdateWithoutRulesDataInput!
}

input RulesetUpsertWithoutAuthorInput {
  where: RulesetWhereUniqueInput!
  update: RulesetUpdateWithoutAuthorDataInput!
  create: RulesetCreateWithoutAuthorInput!
}

input RulesetUpsertWithoutRulesInput {
  where: RulesetWhereUniqueInput!
  update: RulesetUpdateWithoutRulesDataInput!
  create: RulesetCreateWithoutRulesInput!
}

input RulesetWhereInput {
  AND: [RulesetWhereInput!]
  OR: [RulesetWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  game: GameWhereInput
  rules_every: RuleWhereInput
  rules_some: RuleWhereInput
  rules_none: RuleWhereInput
  author: UserWhereInput
}

input RulesetWhereUniqueInput {
  id: ID
}

type RuleSubscriptionPayload {
  mutation: MutationType!
  node: Rule
  updatedFields: [String!]
  previousValues: RulePreviousValues
}

input RuleSubscriptionWhereInput {
  AND: [RuleSubscriptionWhereInput!]
  OR: [RuleSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RuleWhereInput
}

input RuleUpdatecategoriesInput {
  set: [String!]
}

input RuleUpdateInput {
  ruleText: String
  categories: RuleUpdatecategoriesInput
  game: GameUpdateOneWithoutRulesInput
  author: UserUpdateOneWithoutRulesInput
  rulesets: RulesetUpdateManyWithoutRulesInput
}

input RuleUpdateManyWithoutAuthorInput {
  create: [RuleCreateWithoutAuthorInput!]
  connect: [RuleWhereUniqueInput!]
  disconnect: [RuleWhereUniqueInput!]
  delete: [RuleWhereUniqueInput!]
  update: [RuleUpdateWithoutAuthorInput!]
  upsert: [RuleUpsertWithoutAuthorInput!]
}

input RuleUpdateManyWithoutGameInput {
  create: [RuleCreateWithoutGameInput!]
  connect: [RuleWhereUniqueInput!]
  disconnect: [RuleWhereUniqueInput!]
  delete: [RuleWhereUniqueInput!]
  update: [RuleUpdateWithoutGameInput!]
  upsert: [RuleUpsertWithoutGameInput!]
}

input RuleUpdateManyWithoutRulesetsInput {
  create: [RuleCreateWithoutRulesetsInput!]
  connect: [RuleWhereUniqueInput!]
  disconnect: [RuleWhereUniqueInput!]
  delete: [RuleWhereUniqueInput!]
  update: [RuleUpdateWithoutRulesetsInput!]
  upsert: [RuleUpsertWithoutRulesetsInput!]
}

input RuleUpdateWithoutAuthorDataInput {
  ruleText: String
  categories: RuleUpdatecategoriesInput
  game: GameUpdateOneWithoutRulesInput
  rulesets: RulesetUpdateManyWithoutRulesInput
}

input RuleUpdateWithoutAuthorInput {
  where: RuleWhereUniqueInput!
  data: RuleUpdateWithoutAuthorDataInput!
}

input RuleUpdateWithoutGameDataInput {
  ruleText: String
  categories: RuleUpdatecategoriesInput
  author: UserUpdateOneWithoutRulesInput
  rulesets: RulesetUpdateManyWithoutRulesInput
}

input RuleUpdateWithoutGameInput {
  where: RuleWhereUniqueInput!
  data: RuleUpdateWithoutGameDataInput!
}

input RuleUpdateWithoutRulesetsDataInput {
  ruleText: String
  categories: RuleUpdatecategoriesInput
  game: GameUpdateOneWithoutRulesInput
  author: UserUpdateOneWithoutRulesInput
}

input RuleUpdateWithoutRulesetsInput {
  where: RuleWhereUniqueInput!
  data: RuleUpdateWithoutRulesetsDataInput!
}

input RuleUpsertWithoutAuthorInput {
  where: RuleWhereUniqueInput!
  update: RuleUpdateWithoutAuthorDataInput!
  create: RuleCreateWithoutAuthorInput!
}

input RuleUpsertWithoutGameInput {
  where: RuleWhereUniqueInput!
  update: RuleUpdateWithoutGameDataInput!
  create: RuleCreateWithoutGameInput!
}

input RuleUpsertWithoutRulesetsInput {
  where: RuleWhereUniqueInput!
  update: RuleUpdateWithoutRulesetsDataInput!
  create: RuleCreateWithoutRulesetsInput!
}

input RuleWhereInput {
  AND: [RuleWhereInput!]
  OR: [RuleWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  ruleText: String
  ruleText_not: String
  ruleText_in: [String!]
  ruleText_not_in: [String!]
  ruleText_lt: String
  ruleText_lte: String
  ruleText_gt: String
  ruleText_gte: String
  ruleText_contains: String
  ruleText_not_contains: String
  ruleText_starts_with: String
  ruleText_not_starts_with: String
  ruleText_ends_with: String
  ruleText_not_ends_with: String
  game: GameWhereInput
  author: UserWhereInput
  rulesets_every: RulesetWhereInput
  rulesets_some: RulesetWhereInput
  rulesets_none: RulesetWhereInput
}

input RuleWhereUniqueInput {
  id: ID
}

type Subscription {
  game(where: GameSubscriptionWhereInput): GameSubscriptionPayload
  rule(where: RuleSubscriptionWhereInput): RuleSubscriptionPayload
  ruleset(where: RulesetSubscriptionWhereInput): RulesetSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String!
  name: String
  avatar: String
  auth0id: String!
  identity: String
  games: GameCreateManyWithoutUsersInput
  rules: RuleCreateManyWithoutAuthorInput
  rulesets: RulesetCreateManyWithoutAuthorInput
}

input UserCreateManyWithoutGamesInput {
  create: [UserCreateWithoutGamesInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneWithoutRulesetsInput {
  create: UserCreateWithoutRulesetsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutRulesInput {
  create: UserCreateWithoutRulesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutGamesInput {
  email: String!
  name: String
  avatar: String
  auth0id: String!
  identity: String
  rules: RuleCreateManyWithoutAuthorInput
  rulesets: RulesetCreateManyWithoutAuthorInput
}

input UserCreateWithoutRulesetsInput {
  email: String!
  name: String
  avatar: String
  auth0id: String!
  identity: String
  games: GameCreateManyWithoutUsersInput
  rules: RuleCreateManyWithoutAuthorInput
}

input UserCreateWithoutRulesInput {
  email: String!
  name: String
  avatar: String
  auth0id: String!
  identity: String
  games: GameCreateManyWithoutUsersInput
  rulesets: RulesetCreateManyWithoutAuthorInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  avatar_ASC
  avatar_DESC
  auth0id_ASC
  auth0id_DESC
  identity_ASC
  identity_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  name: String
  avatar: String
  auth0id: String!
  identity: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateInput {
  email: String
  name: String
  avatar: String
  auth0id: String
  identity: String
  games: GameUpdateManyWithoutUsersInput
  rules: RuleUpdateManyWithoutAuthorInput
  rulesets: RulesetUpdateManyWithoutAuthorInput
}

input UserUpdateManyWithoutGamesInput {
  create: [UserCreateWithoutGamesInput!]
  connect: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  delete: [UserWhereUniqueInput!]
  update: [UserUpdateWithoutGamesInput!]
  upsert: [UserUpsertWithoutGamesInput!]
}

input UserUpdateOneWithoutRulesetsInput {
  create: UserCreateWithoutRulesetsInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutRulesetsInput
  upsert: UserUpsertWithoutRulesetsInput
}

input UserUpdateOneWithoutRulesInput {
  create: UserCreateWithoutRulesInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutRulesInput
  upsert: UserUpsertWithoutRulesInput
}

input UserUpdateWithoutGamesDataInput {
  email: String
  name: String
  avatar: String
  auth0id: String
  identity: String
  rules: RuleUpdateManyWithoutAuthorInput
  rulesets: RulesetUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutGamesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutGamesDataInput!
}

input UserUpdateWithoutRulesDataInput {
  email: String
  name: String
  avatar: String
  auth0id: String
  identity: String
  games: GameUpdateManyWithoutUsersInput
  rulesets: RulesetUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutRulesetsDataInput {
  email: String
  name: String
  avatar: String
  auth0id: String
  identity: String
  games: GameUpdateManyWithoutUsersInput
  rules: RuleUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutRulesetsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutRulesetsDataInput!
}

input UserUpdateWithoutRulesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutRulesDataInput!
}

input UserUpsertWithoutGamesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutGamesDataInput!
  create: UserCreateWithoutGamesInput!
}

input UserUpsertWithoutRulesetsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutRulesetsDataInput!
  create: UserCreateWithoutRulesetsInput!
}

input UserUpsertWithoutRulesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutRulesDataInput!
  create: UserCreateWithoutRulesInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  auth0id: String
  auth0id_not: String
  auth0id_in: [String!]
  auth0id_not_in: [String!]
  auth0id_lt: String
  auth0id_lte: String
  auth0id_gt: String
  auth0id_gte: String
  auth0id_contains: String
  auth0id_not_contains: String
  auth0id_starts_with: String
  auth0id_not_starts_with: String
  auth0id_ends_with: String
  auth0id_not_ends_with: String
  identity: String
  identity_not: String
  identity_in: [String!]
  identity_not_in: [String!]
  identity_lt: String
  identity_lte: String
  identity_gt: String
  identity_gte: String
  identity_contains: String
  identity_not_contains: String
  identity_starts_with: String
  identity_not_starts_with: String
  identity_ends_with: String
  identity_not_ends_with: String
  games_every: GameWhereInput
  games_some: GameWhereInput
  games_none: GameWhereInput
  rules_every: RuleWhereInput
  rules_some: RuleWhereInput
  rules_none: RuleWhereInput
  rulesets_every: RulesetWhereInput
  rulesets_some: RulesetWhereInput
  rulesets_none: RulesetWhereInput
}

input UserWhereUniqueInput {
  id: ID
  email: String
  auth0id: String
}
